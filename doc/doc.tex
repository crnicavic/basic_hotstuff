\documentclass[12pt]{article}                                                   
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}
\usepackage{anyfontsize}
\usepackage{microtype}
\usepackage{hyperref}
\usepackage{indentfirst}
\usepackage{placeins}
\usepackage{mathtools}                                                          
\usepackage{amsmath}
\usepackage[labelformat=simple]{subfig}
\usepackage{tabularx}
\usepackage{fontspec}
\usepackage{caption}
\usepackage{geometry} 
\usepackage{float}
	\geometry{
		a4paper,
		lmargin=3cm,
		rmargin=2cm,
		tmargin=2cm,
		bmargin=2cm
	}
\renewcommand{\contentsname}{Sadržaj}
\setmainfont[Mapping=tex-text]{Times New Roman}
\renewcommand{\thesubfigure}{\relax}  % Do nothing for the counter »subfigure«
\newlength{\plotheight}
\setlength{\plotheight}{4.5cm}
\def\plotscale{0.65}
\begin{document}

\begin{titlepage}
	\begin{center}
        \vspace*{1cm}
        \Large
        \textbf{Univerzitet u Novom Sadu\\}
        \vspace{0.3cm}
        \Large
        Fakultet tehničkih nauka
        \vfill
		\Huge
		\textbf{Implementacija i analiza \\ ponašanja Hotstuff BFT \\ konsenzus algoritma}
        \vfill
        \large
        Ognjen Čavić\\
        Novi Sad, februar 2026.
    \end{center}
\end{titlepage}
\tableofcontents
\break
\section{Uvod}
Savremeni informacioni sistemi u velikoj meri se oslanjaju na distribuirane
sisteme, u kojima više računarskih čvorova sarađuje kako bi obezbedili pouzdano
i efikasno izvršavanje zadataka. Ovakvi sistemi omogućuju skalabilnost,
paralelno izvršavanje i visoku dostupnost, što ih čini osnovom velikog broja
današnjih softverskih rešenja.

Jedan od osnovnih pristupa za povećanje pouzdanosti distribuiranih sistema
jeste replikacija stanja između više čvorova. Ovaj princip formalizovan je kroz
koncept \textbf{replikacije mašine stanja} (\textit{State machine replication - SMR}),
prema kome sve replike u sistemu izvršavaju iste operacije u istom redosledu,
čime se obezbeđuje konzistentno ponašanje sistema i tolerancija na pojedinačne
otkaze.

Da bi SMR bio realizovan u realnim uslovima, neophodno je obezbediti saglasnost
između replika o redosledu izvršavanja operacija. Ovaj proces mora garantovati
bezbednost (\textit{safety}), u smislu očuvanja konzistentnosti sistema, kao i živost
(\textit{liveness}), odnosno mogućnost da sistem nastavi sa radom u prisustvu grešaka.
Ovi zahtevi postaju naročito složeni u prisustvu vizantijskih otkaza, kada se
pojedini čvorovi mogu ponašati proizvoljno, uključujući prestanak rada ili
slanje kontradiktornih informacija drugim učesnicima sistema.

Konsenzus algoritmi opisuju način na koji se čvorovi dogovaraju o redosledu
izvršavanja operacija. Ukoliko algoritam omogućava sistemu da nastavi sa radom 
i u prisustvu vizantijskih otkaza, za algoritam se može reći da je tolerantan
na vizantijske otkaze (Byzantine fault tolerance - BFT).

\textbf{Hotstuff} je BFT konsenzus algoritam zasnovan na vođi (\textit{leader-based}) 
namenjen realizaciji replikacije mašine stanja u parcijalno sinhronom mrežnom
modelu. Algoritam je koncipiran sa ciljem da bude primenjiv u sistemima sa
velikim brojem čvorova, koje se često nazivaju replikama, uz jednostavnu
strukturu i efikasno dostizanje saglasnosti.

Ovaj rad obuhvata analizu ključnih principa rada HotStuff algoritma i njegovih
fundamentalnih struktura podataka, koje omogućuju pouzdano postizanje
konsenzusa u okviru SMR modela sa vizantijskim otkazima. Na osnovu izloženog
teorijskog okvira razvijena je implementacija algoritma i sprovedena evaluacija
njegovih karakteristika kroz skup eksperimenata.
Rezultati ovih eksperimenata korišćeni su za procenu ispravnosti rada algoritma,
njegove efikasnosti i ponašanja u slučaju vizantijskih otkaza.
\newpage
\section{Svojstva algoritma}
\subsection{Bezbednost i živost}
Osnovni zahtevi koje konsenzus algoritam u okviru SMR mora da ispuni jesu
bezbednost i živost. Bezbednost podrazumeva da sve korektne replike izvršavaju
operacije u istom redosledu, odnosno da ne može doći do divergentnog stanja
sistema. Drugim rečima, jednom doneta odluka ne sme biti promenjena niti
protivrečiti nekoj drugoj odluci donesene od strane korektnih replika.

Živost označava sposobnost sistema da nastavi sa radom i da donosi nove odluke
uprkos prisustvu grešaka i kašnjenja u komunikaciji. Formalno, živost garantuje
da će svaka ispravna operacija predložena od strane klijenta u konačnom vremenu
biti izvršena, pod pretpostavkom da mrežni uslovi postanu dovoljno povoljni.

Ova dva svojstva predstavljaju temelj SMR modela i ne mogu se razmatrati
nezavisno: protokol koji obezbeđuje samo bezbednost bez živosti dovodi do 
zastoja sistema, dok protokol koji garantuje živost bez bezbednosti ugrožava
konzistentnost stanja replika.
\subsection{Dostizanje konsenzusa zasnovano na vođi}
U velikom broju savremenih konsenzus algoritama proces postizanja saglasnosti
organizovan je kroz ulogu vođe, koja se periodično dodeljuje jednom od
čvorova u sistemu u okviru diskretnih logičkih intervala poznatih kao pogledi
ili mandati (\textit{views}). Tokom jednog pogleda, postavljeni vođa je odgovoran
za iniciranje predloga narednih operacija, kao i za koordinaciju glasanja, tj.
prikupljanje odgovora na predloženu operaciju. Način biranja vođe je poznat svim
ispravnim replikama, jer predstavlja determinističku funkciju koja na osnovu
rednog broja pogleda vraća ko je vođa za određeni pogled.

Ovakva organizacija izvršavanja  omogućava smanjenje komunikacione složenosti,
jer se predlozi distribuiraju iz jednog centralnog izvora ka ostalim
replikama, koje svoje glasove šalju vođi. Na taj način se izbegava situacija u
kojoj više replika istovremeno predlaže konkurentne operacije, što bi dovelo do
povećanog broja razmenjenih poruka i složenije sinhronizacije sistema.

Uloga vođe nije trajna i vezana je isključivo za jedan pogled. U slučaju da je
vođa spor, postane nedostupan ili se ponaša nekorektno, sistem
prelazi u naredni pogled u kome druga replika preuzima ulogu vođe. Mehanizam
promene pogleda predstavlja osnovni način očuvanja živosti protokola i sprečava
da neispravno ponašanje pojedinačnog čvora trajno blokira napredak sistema.

Mana ovog pristupa je u tome što vođa predstavlja jedinstvenu tačku zastoja,
budući da bilo kakvi otkazi u funkcionisanju vođe izazivaju prestanak rada
algoritma i zahteva prelazak u sledeći pogled gde će biti odabran drugi vođa.
Međutim, jedna od glavnih prednosti Hotstuff algoritma jeste brz i jednostavan
mehanizam promene vođe, čime se omogućuje očuvanje bezbednosti i živosti.

\subsection{Linearna promena pogleda (\textit{Linear view change})}

Linearna promena pogleda predstavlja sposobnost algoritma da nakon stabilizacije
mrežne komunikacije omogući ispravnom vođi da sprovede dostizanje saglasnosti
replika uz razmenu $O(n)$ poruka, gde $n$ označava broj replika u sistemu. Time
se obezbeđuje da u stabilnim mrežnim uslovima algoritam ostvaruje napredak sa
minimalnim komunikacionim troškom.

U slučaju otkaza vođe, sistem prelazi u naredni pogled u kome nova replika
preuzima ulogu vođe i ponavlja postupak dostizanja saglasnosti sa istom
komunikacionom složenošću. Najgori slučaj $O(n^2)$ javlja se tek usled više
uzastopnih otkaza vođe, pri čemu se linearni trošak akumulira kroz veći broj
pogleda.

\newpage

\subsection{Optimistična odzivnost (\textit{Optimistic responsiveness})}

Optimistična odzivnost podrazumeva osobinu da nakon stabilizacije mreže ispravni
vođa treba da sakupi dovoljan broj glasova kako bi sastavio predlog koji garantuje
napredak. To znači da korektni vođa koordiniše dostizanje konsenzusa brzinom
koja je uslovljena karakteristikama mrežne komunikacije.

\newpage

\section{Model sistema}

\subsection{Model učesnika i prava pristupa(\textit{permissioned} okruženje)}

HotStuff algoritam je namenjen radu u tzv. \textit{permissioned} okruženju, u
kome skup učesnika algoritma čini konačan i poznat broj replika. Svaka replika
poseduje jedinstveni identitet i učestvuje u procesu donošenja odluka u skladu
sa definisanim pravilima protokola.

Za razliku od \textit{permissionless} sistema, u kojima novi čvorovi mogu
slobodno pristupati mreži, u permissioned okruženju pristup protokolu je
ograničen i kontrolisan. Ovakav model je pogodan za sisteme u kojima se zahteva
veći stepen pouzdanosti, predvidivosti i kontrole nad učesnicima, kao što su
distribuirane baze podataka, poslovni informacioni sistemi i privatne blokčejn mreže.

Koncept blokčejna može se posmatrati kao specijalan slučaj replikacije mašine stanja,
u kome se niz izvršenih operacija organizuje u strukturu ulančanih blokova.
Blok podrazumeva strukturu podataka koja sadrži skup operacija, kao i pokazivač
ka prethodnom bloku u lancu. Svaka replika održava lokalnu kopiju lanca blokova
i izvršava iste operacije u istom redosledu, čime se obezbeđuje konzistentno
stanje sistema.

\subsection{Modeli mrežne komunikacije}

Komunikacija između replika odvija se putem mreže koja može ispoljavati
različite stepene nepredvidivosti u pogledu kašnjenja poruka. U literaturi se
najčešće razmatraju tri osnovna mrežna modela: sinhroni, asinhroni i parcijalno
sinhroni.

U sinhronom mrežnom modelu pretpostavlja se da postoji poznata gornja vremenska
granica prenosa poruka između replika, koja se često označava sa $\Delta$. Ova
pretpostavka omogućava jednostavno projektovanje algoritma, ali ona retko važi
u realnim distribuiranim sistemima.

U asinhronom mrežnom modelu ne postoje pretpostavke o vremenu isporuke poruka. 
Ovaj model odražava visoku nepredvidivost mreže, dokazano je da u potpuno
asinhronom okruženju nije moguće garantovati i bezbednost i živost
determinističkih BFT konsenzus algoritama.

HotStuff se oslanja na parcijalno sinhroni mrežni model, koji se
inicijalno ponaša isto kao asinhrona mreža, ali nakon nekog nepoznatog
vremenskog trenutka stabilizacije mreže (\textit{Global stabilisation time - GST})
komunikacija između replika postaje sinhrona, odnosno poruke se isporučuju
unutar neke konačne vremenske granice. Ovaj model omogućava algoritmu da očuva
bezbednost u svim uslovima rada, dok se živost garantuje tek nakon GST.

\subsection{Vizantijski otkazi}

HotStuff algoritam pretpostavlja prisustvo replika koje su podložne vizantijskim
otkazima, za koje se kaže da su vizantijski neispravne, što znači da su sklone
proizvoljnom ponašanju.  Vizantijski otkazi obuhvataju širok spektar neispravnih
ponašanja, uključujući prestanak rada replike, nasumično kašnjenje poruka, kao i
slanje kontradiktornih informacija različitim učesnicima sistema.

U okviru razmatranog modela, pretpostavlja se da najviše $f$ replika može biti
vizantijski neispravno. Kako bi se garantovalo da vizantijski neispravne replike
ne mogu da poremete dostizanje konsenzusa, potrebno je da postoji najmanje
$2f+1$ ispravnih replika, odnosno ukupan broj učesnika u sistemu mora biti veći
ili jednak $3f+1$.

\newpage

\section{Hotstuff konsenzus algoritam}

\subsection{Uslovi rada algoritma}

Sistem se sastoji od skupa od $n$ replika, od kojih najviše $f$ može biti
vizantijski neispravno, pri čemu važi uslov $n \ge 3f + 1$. Replike komuniciraju
razmenom poruka putem parcijalno sinhrone mreže i organizovane su u diskretne
logičke intervale izvršavanja, nazvane pogledi (\textit{views}). U svakom
pogledu tačno jedna replika ima ulogu vođe i odgovorna je za predlaganje
narednog bloka operacija.

Hotstuff se koristi šemom potpisa sa pragom, u kojoj postoji jedan javni ključ,
koji je poznat svim replikama, dok svaka replika poseduje jedinstveni privatni
ključ. U $(k,n)$ šemi potpisa sa pragom, replika može generisati parcijalni
potpis nad porukom $m$, koji predstavlja glas za odgovarajući predlog. Kada
vođa pogleda sakupi barem $k$ parcijalnih potpisa, što je u ovom slučaju $2f+1$,
može ih kombinovati u potpuni potpis koji se naziva serifikat kvoruma (\textit{
Quorum Certificate - QC}). Svaka replika može verifikovati legitimnost tog
potpisa pomoću javnog ključa.

Jedna mogućnost kod vizantijski neispravnih replika jeste da one međusobno
sarađuju, ili da postoji jedan napadač koji upravlja svakom od $f$ neispravnih
replika. Dokle god taj napadač nema mogućnost da generiše $2f+1$ potpisa, šema
potpisa sa pragom garantuje bezbednost, zato što nije moguće falsifikovati
sertifikat kvoruma za predlog za koji iskrene replike neće glasati.

Pored toga, algoritam koristi kriptografsku heš funkciju $h$, koja preslikava
poruke bilo koje dužine u izlaz fiksne dužine. Heš funkcija mora biti otporna
na sudare, što omogućava da se vrednost $h(m)$ koristi kao jedinstveni
identifikator poruke ili bloka u okviru protokola. Na ovaj način se
pojednostavljuje razmena poruka i verifikacija sertifikata kvoruma.

\subsection{Strukture podataka}

Osnovna struktura podataka na koju se algoritam oslanja jeste \textbf{poruka}
(\textit{Message}). Ona predstavlja jedinicu komunikacije između replika,
sadrži informacije o tome u kojoj fazi se algoritam nalazi, predloženi blok oko
kojeg se replike dogovaraju, kao i redni broj pogleda.

Budući da je cela svrha Hotstuff da se replike dogovore oko narednih operacija,
\textbf{blok} predstavlja kontejner za skup operacija. Blok definišu sam skup
operacija, visina tj. udaljenost od početnog bloka i pokazivač ka poslednjem
bloku u lancu izvršenih blokova, kao i sertifikat kvoruma za taj blok.

Glavni mehanizam bezbednosti jeste \textbf{sertifikat kvoruma}(\textit{ Quorum
Certificate - QC}). On predstavlja kombinovani potpis i služi kao dokaz da je
dovoljan broj replika dalo svoj glas za određeni predlog. Pored potpisa uz QC
se šalju i sam predlog na koji se odnosi, pogled u kojem je sastavljen, kao i
faza algoritma u kojoj su skupljani potpisi.

Pored lanca izvršenih operacija, svaka replika mora da čuva i nekoliko lokalnih
promenljivih radi praćenja stanja algoritma. Pre svega mora da se prati redni
broj pogleda u kojem se trenutno nalazi. Takođe se drže najnoviji sertifikati
kvoruma iz prve dve runde glasanja, tj. faze pripreme (\textit{prepareQC}) i
iz faze pred-potvrđivanja(\textit{lockedQC}). Ova dva sertifikata su bitna zato
što su potrebni za provere bezbednosti, \textit{prepareQC} se šalje pri prelazu
u novi pogled, dok je \textit{lockedQC} ključan za izvršavanje funkcije koja
proverava bezbednost predloga (\textit{safeNode}). Blok je bezbedan ukoliko
se nastavlja na blok iz \textit{lockedQC} ili ako je iz novijeg pogleda od onog
u kojem je \textit{lockedQC} nastao.


\subsection{Faze algoritma}

Hotstuff je organizovan u diskretne logičke jedinice zvane pogledima. Svaki
pogled je organizovan u sastavljanje predloga, nakon čega slede tri faze
glasanja i ukoliko se one odviju uspešno, na kraju se operacije u tom bloku
izvršavaju. Ovakva organizacija garantuje da neće doći do divergencije između
stanja replika.

Svaki pogled počinje tako što čvorovi šalju poruku prelaska u nov pogled 
(\textit{new-view message}) vođi za taj mandat koja sa sobom nosi \textit{prepareQC}.
Sakupljanjem $2f+1$ takvih poruka počinje faza pripreme (\textit{prepare}), u
kojoj vođa priprema predlog bloka šalje ga svim učesnicima sistema(\textit{broadcast}).
Po prijemu predloga, replika proverava da li je on bezbedan (\textit{safe node})
i ukoliko jeste, generiše se potpis koji se šalje vođi.

Sledeća faza je pred-potvrđivanje (\textit{precommit}). Uloga ove faze jeste da
vođa formira serifikat kvoruma iz faze pripreme(\textit{prepareQC}), kao i 
distribucija istog. Značaj ovog koraka je takođe u tome što nudi replikama
opciju da se "predomisle" oko predloga. Po prijemu poruke od vođe, replike
postavljaju lokalni \textit{prepareQC} na sertifikat koji se nalazi u pristigloj
poruci od vođe.

Poslednja runda glasanja je faza posvećivanja (\textit{commit}), gde se formira
sertifikat za fazu pred-potvrđivanja (\textit{precommitQC}) koji se emituje svim
replikama, po prijemu se postavlja da bude novi \textit{lockedQC} i vraća svoj
glas vođi. Glavna uloga ove faze jeste potvrđivanje postignutog stanja konsenzusa.

Prikupljanjem glasova i formiranjem  \textit{commitQC}, koji predstavlja dokaz
da je blok prošao sve runde glasanja, vođa započinje fazu odluke (\textit{decide})
gde se operacije u tom bloku konačno izvršavaju, tako što šalje poruku koja
sadrži formirani sertifikat. Po prijemu, replika izvršava operacije i dodaje
blok u lanac izvršenih. Nakon toga se redni broj pogleda povećava za jedan i ceo
proces počinje iznova.
\end{document}
